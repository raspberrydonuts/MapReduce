#include "mapreduce.h"

void spawnMapper(int nMappers) {
	for (int i = 0; i < nMappers; i++) {
		pid_t pid = fork();
		if (pid == 0) {
			int pidToInt = i+1;
			char * pidToChar = malloc(12);
			sprintf(pidToChar, "%d", pidToInt);
			if (execlp("./mapper", "./mapper", pidToChar, NULL) < 0) {
				printf("\nERROR: execl on mapper failed\n");
				exit(1);
			}
			free(pidToChar);
		} else {

		}

	}
}

void waitForAll(int nProcess) {
	for (int i = 0; i < nProcess; i++) {
		wait(NULL);
	}
}

void spawnReducers(int nReducers) {
	for (int i = 0; i < nReducers; i++) {
		pid_t pid = fork();
		if (pid == 0) {
			int pidToInt = i+1;
			char * pidToChar = malloc(12);
			sprintf(pidToChar, "%d", pidToInt);
			if (execlp("./reducer", "./reducer", pidToChar, NULL) < 0) {
				printf("\nERROR: execl on reducer failed\n");
				exit(1);
			}
			free(pidToChar);
		} else {

		}
	}
}

int main(int argc, char *argv[]) {

	if(argc < 4) {
		printf("Less number of arguments.\n");
		printf("./mapreduce #mappers #reducers inputFile\n");
		exit(0);
	}

	// ###### DO NOT REMOVE ######
	int nMappers 	= strtol(argv[1], NULL, 10);
	int nReducers 	= strtol(argv[2], NULL, 10);
	char *inputFile = argv[3];

	// ###### DO NOT REMOVE ######
	// Directory creation and removal
	bookeepingCode();

	// ###### DO NOT REMOVE ######
	pid_t pid = fork();
	if(pid == 0){
		//send chunks of data to the mappers in RR fashion
		sendChunkData(inputFile, nMappers);
		exit(0);
	}
	sleep(1);

	// To do
	// spawn mappers processes and run 'mapper' executable using exec
	spawnMapper(nMappers);

	// To do
	// wait for all children to complete execution
    waitForAll(nMappers+1);
	// exit(0);

	// ###### DO NOT REMOVE ######
    // shuffle sends the word.txt files generated by mapper
    // to reducer based on a hash function
	pid = fork();
	if(pid == 0){
		shuffle(nMappers, nReducers);
		exit(0);
	}
	sleep(1);


	// To do
	// spawn reducer processes and run 'reducer' executable using exec
	spawnReducers(nReducers);

	// To do
	// wait for all children to complete execution
	waitForAll(nReducers+1);

	return 0;
}
